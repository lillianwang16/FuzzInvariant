%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan,10pt]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[ECS 289C]{}{Programming Languages and Compilers}{Davis, CA USA}
\acmYear{2017}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\begin{document}

%% Title information
\title[Short Title]{Invariant-based AFL Fuzz testing}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Wen-Chi Hung}
\affiliation{
  \position{Department of Computer Science}
  \department{University of California, Davis}              %% \department is recommended
  \institution{wenhung@ucdavis.edu}            %% \institution is required
}

\author{Xinyi Zhang}
\affiliation{
  \position{Department of Computer Science}
  \department{University of California, Davis}              %% \department is recommended
  \institution{xykzhang@ucdavis.edu}            %% \institution is required
}

\author{Yiran   Wang}
\affiliation{
  \position{Department of Computer Science}
  \department{University of California, Davis}              %% \department is recommended
  \institution{wyrwang@ucdavis.edu}            %% \institution is required
}

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. Some fuzzers (like AFL and LLVM?s libfuzzer) have instrumentation compiled inside the tested software so the fuzzer can see how the program behaves internally. While fuzzing tools are generally aimed to explore and test undefined areas that may trigger bugs, how to get those test cases   for   an   undefined   area   is   the   core   problem.

American fuzzy lop(AFL) is a well-known technique that has successfully detect significant software bugs in dozens of major free software projects. The strategy for AFL is to mutate a user-defined test case by applying various modifications to initial user input. The core procedures of AFL: 1, take next input file from the queue 2, mutate the file 3, record unique mutate output. The iterations of these three steps will be repeated until new internal states in the targeted binary been triggered. AFL performs well to find some bugs, but it may take a very long time to trigger those interesting results. The mutation of test cases can be forever in order to be explicit in this exploring process. Some techniques, thus, are used to prevent redundant and repeated works by choosing different exploration paths as much as possible. The AFL uses coverage test as the standard to distinguish test cases. In another word, starts from that initial stage, it automatically discovers   clean,   interesting   test   cases   by   coverage   test.

\section{Motivation}

While an important step of fuzzers, like AFL, is to repeatedly mutate the file using a balanced and well-researched variety of traditional fuzzing strategies, it?s not trivial to recognize those ?clean and interesting? test cases to do the real testing. If the test inputs generated by mutating cannot be effectively recognized as a repetition of an existing one, redundant work will be done again. The goal is to have an effective method to cover more program paths and trigger unexpected behavior. While the coverage test is used in the current version of AFL, we want to explore whether there?s a better way, such as using ?invariants?(relatively ?invariants? ) as criteria. If we could reduce more repetition, the efficiency of AFL can be improved.

\section{Solution}
In this project, we would like to apply the comparison of ?invariants? in programs instead of just the criteria based on the coverage in AFL. The ?invariants? here is not the true invariants for the program, but relatively unchanged variants compared with several inputs. To find the ?invariants? in the program, we plan to use Daikon. Daikon is an implementation of dynamic detection of likely invariants. During the detection process, the Daikon invariant detector reports likely program invariants. If the ?invariants? detected by Daikon are different from the ?invariants? from previous inputs, we save the mutation for future variations. There are three plans to integrate the ?invariants? detection with the original AFL and we plan to compare the results of all those and the original AFL.

\begin{enumerate}
\item Replace the coverage test.
\item Apply invariants test to the results from coverage test.
\item Combine the results from invariant and coverage test.
\end{enumerate}

In AFL, the mutated test cases are pushed into a queue if they are considered ?interesting?. We plan to replace that method that detects only the coverage to a system call to another application(Daikon) that return a pool of ?interesting? cases back to the AFL. We plan to modify the AFL to take new test cases in the three plans we mentioned before.

\section{Comparison}
For the coverage-based fuzzer, if a mutation triggers execution of a previously-uncovered path in the code under test, then that mutation is saved to the input pool for future variations. We want to add invariants test to the fuzzer. The fuzzer generates random mutations based on the sample inputs in the current corpus. Besides the coverage tests in original AFL, we use ?invariants? to consider whether this test case should be use or not less. , if certain test cases generates a new a set of ?invariants? that differ from previous from Daikon, we will continue the AFL to test the program using this new mutation and take it as the seed to generate more test cases.

\section{Related Work}
\subsection{Fuzz testing}
Fuzz testing is an automated software testing technique. Depending on whether the fuzzers are aware of program structure, fuzzers could be categorized as white-, grey-, or black-box fuzzers.

Symbolic execution based white-box fuzzers like Klee[1] or Katch[2] use symbolic program analysis and constraint solving to accurately direct the search in test generation as and when required.

American Fuzzy lop (AFL)[3] is a coverage-based fuzzers. Unlike symbolic execution, AFL has the ability to generate lots of test cases. Its attempt to cover more program paths using mutations of seed inputs without incurring any overhead of program analysis. Some improvements have been introduced based on AFL. In the paper of AFL Fast[4], they present the structure of coverage-based Greybox Fuzzing (CGF). The recent work AFLGo[5] is focusing on directed grey box fuzzing. It can achieve higher performance if there is a specific target to be tested. However, in our experiment, we apply the original edition of AFL because the possible application can be more general.

Since the AFL conduct random mutation to generate test cases, straying to the wrong direction can cause huge overhead. Combining the AFL to invariant-based testing can be a solution. Because the huge amount of test cases generated by mutation, the invariant-best testing tool can utilize those test cases to check whether they are in the range of current invariants. On one hand, those test cases remained can be applied on the invariant -best testing tool to produce more precise invariant; on the other hand, since the invariant-best testing tool delete some cases generated by AFL, the AFL can focus on those more promising routes.

\subsection{Discovering Program Invariants} 
Daikon[7] can conduct dynamic inference of invariants for applications in software evolution. Dynamically inferred invariants also could be used in many situations that declared or statically inferred invariants can and, in some cases, the application of dynamic ones may be more effective. Invariants have many uses in computer science, and is considered as an indicator of triggering new running status of the program.Since the invariants generated by Daikon represent the current status of the program with input test cases, test cases which are out of the range of invariants are highly possible to discover a new path for the target program. It is thus a possible method to be used to eliminate useless data from the list of mutation test inputs from AFL. In addition, Daikon has the compatibility in C language which is ideal for integrating with AFL. Other tools that we considered such as Deduce[8], are simpler than Daikon, but doesn?t support C program.

\section{Tools}

\begin{enumerate}
\item American Fuzzy Loop
\item The Daikon Invariant detector
\end{enumerate}


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
